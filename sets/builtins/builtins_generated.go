// Code generated by builtins/builtins.go DO NOT EDIT.
// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package builtins

import "sync"

// BoolSet the set of Bools
type BoolSet struct {
	mp map[bool]struct{}
	sync.RWMutex
}

// NewBoolSet returns a new *BoolSet with the initial size set to size
func NewBoolSet(size int) *BoolSet {
	return &BoolSet{
		mp: make(map[bool]struct{}, size),
	}
}

func (s *BoolSet) lock(others ...*BoolSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *BoolSet) readLock(others ...*BoolSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *BoolSet) Values() []bool {
	defer s.readLock()()
	vals := make([]bool, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *BoolSet) Add(val ...bool) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *BoolSet) Del(val ...bool) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *BoolSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *BoolSet) Contains(val ...bool) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *BoolSet with the same elements
func (s *BoolSet) Clone() *BoolSet {
	defer s.readLock()()
	newSet := NewBoolSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *BoolSet with elements from both s and s2
func (s *BoolSet) Union(s2 *BoolSet) *BoolSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *BoolSet with elements that s and s2 have in common
func (s *BoolSet) Intersection(s2 *BoolSet) *BoolSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *BoolSet with the elements that exist in s but not s2
func (s *BoolSet) Diff(s2 *BoolSet) *BoolSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// ByteSet the set of Bytes
type ByteSet struct {
	mp map[byte]struct{}
	sync.RWMutex
}

// NewByteSet returns a new *ByteSet with the initial size set to size
func NewByteSet(size int) *ByteSet {
	return &ByteSet{
		mp: make(map[byte]struct{}, size),
	}
}

func (s *ByteSet) lock(others ...*ByteSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *ByteSet) readLock(others ...*ByteSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *ByteSet) Values() []byte {
	defer s.readLock()()
	vals := make([]byte, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *ByteSet) Add(val ...byte) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *ByteSet) Del(val ...byte) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *ByteSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *ByteSet) Contains(val ...byte) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *ByteSet with the same elements
func (s *ByteSet) Clone() *ByteSet {
	defer s.readLock()()
	newSet := NewByteSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *ByteSet with elements from both s and s2
func (s *ByteSet) Union(s2 *ByteSet) *ByteSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *ByteSet with elements that s and s2 have in common
func (s *ByteSet) Intersection(s2 *ByteSet) *ByteSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *ByteSet with the elements that exist in s but not s2
func (s *ByteSet) Diff(s2 *ByteSet) *ByteSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Complex128Set the set of Complex128s
type Complex128Set struct {
	mp map[complex128]struct{}
	sync.RWMutex
}

// NewComplex128Set returns a new *Complex128Set with the initial size set to size
func NewComplex128Set(size int) *Complex128Set {
	return &Complex128Set{
		mp: make(map[complex128]struct{}, size),
	}
}

func (s *Complex128Set) lock(others ...*Complex128Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Complex128Set) readLock(others ...*Complex128Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Complex128Set) Values() []complex128 {
	defer s.readLock()()
	vals := make([]complex128, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Complex128Set) Add(val ...complex128) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Complex128Set) Del(val ...complex128) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Complex128Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Complex128Set) Contains(val ...complex128) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Complex128Set with the same elements
func (s *Complex128Set) Clone() *Complex128Set {
	defer s.readLock()()
	newSet := NewComplex128Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Complex128Set with elements from both s and s2
func (s *Complex128Set) Union(s2 *Complex128Set) *Complex128Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Complex128Set with elements that s and s2 have in common
func (s *Complex128Set) Intersection(s2 *Complex128Set) *Complex128Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Complex128Set with the elements that exist in s but not s2
func (s *Complex128Set) Diff(s2 *Complex128Set) *Complex128Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Complex64Set the set of Complex64s
type Complex64Set struct {
	mp map[complex64]struct{}
	sync.RWMutex
}

// NewComplex64Set returns a new *Complex64Set with the initial size set to size
func NewComplex64Set(size int) *Complex64Set {
	return &Complex64Set{
		mp: make(map[complex64]struct{}, size),
	}
}

func (s *Complex64Set) lock(others ...*Complex64Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Complex64Set) readLock(others ...*Complex64Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Complex64Set) Values() []complex64 {
	defer s.readLock()()
	vals := make([]complex64, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Complex64Set) Add(val ...complex64) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Complex64Set) Del(val ...complex64) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Complex64Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Complex64Set) Contains(val ...complex64) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Complex64Set with the same elements
func (s *Complex64Set) Clone() *Complex64Set {
	defer s.readLock()()
	newSet := NewComplex64Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Complex64Set with elements from both s and s2
func (s *Complex64Set) Union(s2 *Complex64Set) *Complex64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Complex64Set with elements that s and s2 have in common
func (s *Complex64Set) Intersection(s2 *Complex64Set) *Complex64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Complex64Set with the elements that exist in s but not s2
func (s *Complex64Set) Diff(s2 *Complex64Set) *Complex64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// ErrorSet the set of Errors
type ErrorSet struct {
	mp map[error]struct{}
	sync.RWMutex
}

// NewErrorSet returns a new *ErrorSet with the initial size set to size
func NewErrorSet(size int) *ErrorSet {
	return &ErrorSet{
		mp: make(map[error]struct{}, size),
	}
}

func (s *ErrorSet) lock(others ...*ErrorSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *ErrorSet) readLock(others ...*ErrorSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *ErrorSet) Values() []error {
	defer s.readLock()()
	vals := make([]error, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *ErrorSet) Add(val ...error) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *ErrorSet) Del(val ...error) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *ErrorSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *ErrorSet) Contains(val ...error) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *ErrorSet with the same elements
func (s *ErrorSet) Clone() *ErrorSet {
	defer s.readLock()()
	newSet := NewErrorSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *ErrorSet with elements from both s and s2
func (s *ErrorSet) Union(s2 *ErrorSet) *ErrorSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *ErrorSet with elements that s and s2 have in common
func (s *ErrorSet) Intersection(s2 *ErrorSet) *ErrorSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *ErrorSet with the elements that exist in s but not s2
func (s *ErrorSet) Diff(s2 *ErrorSet) *ErrorSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Float32Set the set of Float32s
type Float32Set struct {
	mp map[float32]struct{}
	sync.RWMutex
}

// NewFloat32Set returns a new *Float32Set with the initial size set to size
func NewFloat32Set(size int) *Float32Set {
	return &Float32Set{
		mp: make(map[float32]struct{}, size),
	}
}

func (s *Float32Set) lock(others ...*Float32Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Float32Set) readLock(others ...*Float32Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Float32Set) Values() []float32 {
	defer s.readLock()()
	vals := make([]float32, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Float32Set) Add(val ...float32) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Float32Set) Del(val ...float32) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Float32Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Float32Set) Contains(val ...float32) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Float32Set with the same elements
func (s *Float32Set) Clone() *Float32Set {
	defer s.readLock()()
	newSet := NewFloat32Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Float32Set with elements from both s and s2
func (s *Float32Set) Union(s2 *Float32Set) *Float32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Float32Set with elements that s and s2 have in common
func (s *Float32Set) Intersection(s2 *Float32Set) *Float32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Float32Set with the elements that exist in s but not s2
func (s *Float32Set) Diff(s2 *Float32Set) *Float32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Float64Set the set of Float64s
type Float64Set struct {
	mp map[float64]struct{}
	sync.RWMutex
}

// NewFloat64Set returns a new *Float64Set with the initial size set to size
func NewFloat64Set(size int) *Float64Set {
	return &Float64Set{
		mp: make(map[float64]struct{}, size),
	}
}

func (s *Float64Set) lock(others ...*Float64Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Float64Set) readLock(others ...*Float64Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Float64Set) Values() []float64 {
	defer s.readLock()()
	vals := make([]float64, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Float64Set) Add(val ...float64) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Float64Set) Del(val ...float64) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Float64Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Float64Set) Contains(val ...float64) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Float64Set with the same elements
func (s *Float64Set) Clone() *Float64Set {
	defer s.readLock()()
	newSet := NewFloat64Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Float64Set with elements from both s and s2
func (s *Float64Set) Union(s2 *Float64Set) *Float64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Float64Set with elements that s and s2 have in common
func (s *Float64Set) Intersection(s2 *Float64Set) *Float64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Float64Set with the elements that exist in s but not s2
func (s *Float64Set) Diff(s2 *Float64Set) *Float64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// IntSet the set of Ints
type IntSet struct {
	mp map[int]struct{}
	sync.RWMutex
}

// NewIntSet returns a new *IntSet with the initial size set to size
func NewIntSet(size int) *IntSet {
	return &IntSet{
		mp: make(map[int]struct{}, size),
	}
}

func (s *IntSet) lock(others ...*IntSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *IntSet) readLock(others ...*IntSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *IntSet) Values() []int {
	defer s.readLock()()
	vals := make([]int, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *IntSet) Add(val ...int) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *IntSet) Del(val ...int) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *IntSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *IntSet) Contains(val ...int) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *IntSet with the same elements
func (s *IntSet) Clone() *IntSet {
	defer s.readLock()()
	newSet := NewIntSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *IntSet with elements from both s and s2
func (s *IntSet) Union(s2 *IntSet) *IntSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *IntSet with elements that s and s2 have in common
func (s *IntSet) Intersection(s2 *IntSet) *IntSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *IntSet with the elements that exist in s but not s2
func (s *IntSet) Diff(s2 *IntSet) *IntSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Int16Set the set of Int16s
type Int16Set struct {
	mp map[int16]struct{}
	sync.RWMutex
}

// NewInt16Set returns a new *Int16Set with the initial size set to size
func NewInt16Set(size int) *Int16Set {
	return &Int16Set{
		mp: make(map[int16]struct{}, size),
	}
}

func (s *Int16Set) lock(others ...*Int16Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Int16Set) readLock(others ...*Int16Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Int16Set) Values() []int16 {
	defer s.readLock()()
	vals := make([]int16, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Int16Set) Add(val ...int16) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Int16Set) Del(val ...int16) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Int16Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Int16Set) Contains(val ...int16) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Int16Set with the same elements
func (s *Int16Set) Clone() *Int16Set {
	defer s.readLock()()
	newSet := NewInt16Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Int16Set with elements from both s and s2
func (s *Int16Set) Union(s2 *Int16Set) *Int16Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Int16Set with elements that s and s2 have in common
func (s *Int16Set) Intersection(s2 *Int16Set) *Int16Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Int16Set with the elements that exist in s but not s2
func (s *Int16Set) Diff(s2 *Int16Set) *Int16Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Int32Set the set of Int32s
type Int32Set struct {
	mp map[int32]struct{}
	sync.RWMutex
}

// NewInt32Set returns a new *Int32Set with the initial size set to size
func NewInt32Set(size int) *Int32Set {
	return &Int32Set{
		mp: make(map[int32]struct{}, size),
	}
}

func (s *Int32Set) lock(others ...*Int32Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Int32Set) readLock(others ...*Int32Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Int32Set) Values() []int32 {
	defer s.readLock()()
	vals := make([]int32, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Int32Set) Add(val ...int32) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Int32Set) Del(val ...int32) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Int32Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Int32Set) Contains(val ...int32) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Int32Set with the same elements
func (s *Int32Set) Clone() *Int32Set {
	defer s.readLock()()
	newSet := NewInt32Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Int32Set with elements from both s and s2
func (s *Int32Set) Union(s2 *Int32Set) *Int32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Int32Set with elements that s and s2 have in common
func (s *Int32Set) Intersection(s2 *Int32Set) *Int32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Int32Set with the elements that exist in s but not s2
func (s *Int32Set) Diff(s2 *Int32Set) *Int32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Int64Set the set of Int64s
type Int64Set struct {
	mp map[int64]struct{}
	sync.RWMutex
}

// NewInt64Set returns a new *Int64Set with the initial size set to size
func NewInt64Set(size int) *Int64Set {
	return &Int64Set{
		mp: make(map[int64]struct{}, size),
	}
}

func (s *Int64Set) lock(others ...*Int64Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Int64Set) readLock(others ...*Int64Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Int64Set) Values() []int64 {
	defer s.readLock()()
	vals := make([]int64, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Int64Set) Add(val ...int64) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Int64Set) Del(val ...int64) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Int64Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Int64Set) Contains(val ...int64) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Int64Set with the same elements
func (s *Int64Set) Clone() *Int64Set {
	defer s.readLock()()
	newSet := NewInt64Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Int64Set with elements from both s and s2
func (s *Int64Set) Union(s2 *Int64Set) *Int64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Int64Set with elements that s and s2 have in common
func (s *Int64Set) Intersection(s2 *Int64Set) *Int64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Int64Set with the elements that exist in s but not s2
func (s *Int64Set) Diff(s2 *Int64Set) *Int64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Int8Set the set of Int8s
type Int8Set struct {
	mp map[int8]struct{}
	sync.RWMutex
}

// NewInt8Set returns a new *Int8Set with the initial size set to size
func NewInt8Set(size int) *Int8Set {
	return &Int8Set{
		mp: make(map[int8]struct{}, size),
	}
}

func (s *Int8Set) lock(others ...*Int8Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Int8Set) readLock(others ...*Int8Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Int8Set) Values() []int8 {
	defer s.readLock()()
	vals := make([]int8, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Int8Set) Add(val ...int8) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Int8Set) Del(val ...int8) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Int8Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Int8Set) Contains(val ...int8) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Int8Set with the same elements
func (s *Int8Set) Clone() *Int8Set {
	defer s.readLock()()
	newSet := NewInt8Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Int8Set with elements from both s and s2
func (s *Int8Set) Union(s2 *Int8Set) *Int8Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Int8Set with elements that s and s2 have in common
func (s *Int8Set) Intersection(s2 *Int8Set) *Int8Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Int8Set with the elements that exist in s but not s2
func (s *Int8Set) Diff(s2 *Int8Set) *Int8Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// RuneSet the set of Runes
type RuneSet struct {
	mp map[rune]struct{}
	sync.RWMutex
}

// NewRuneSet returns a new *RuneSet with the initial size set to size
func NewRuneSet(size int) *RuneSet {
	return &RuneSet{
		mp: make(map[rune]struct{}, size),
	}
}

func (s *RuneSet) lock(others ...*RuneSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *RuneSet) readLock(others ...*RuneSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *RuneSet) Values() []rune {
	defer s.readLock()()
	vals := make([]rune, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *RuneSet) Add(val ...rune) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *RuneSet) Del(val ...rune) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *RuneSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *RuneSet) Contains(val ...rune) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *RuneSet with the same elements
func (s *RuneSet) Clone() *RuneSet {
	defer s.readLock()()
	newSet := NewRuneSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *RuneSet with elements from both s and s2
func (s *RuneSet) Union(s2 *RuneSet) *RuneSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *RuneSet with elements that s and s2 have in common
func (s *RuneSet) Intersection(s2 *RuneSet) *RuneSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *RuneSet with the elements that exist in s but not s2
func (s *RuneSet) Diff(s2 *RuneSet) *RuneSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// StringSet the set of Strings
type StringSet struct {
	mp map[string]struct{}
	sync.RWMutex
}

// NewStringSet returns a new *StringSet with the initial size set to size
func NewStringSet(size int) *StringSet {
	return &StringSet{
		mp: make(map[string]struct{}, size),
	}
}

func (s *StringSet) lock(others ...*StringSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *StringSet) readLock(others ...*StringSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *StringSet) Values() []string {
	defer s.readLock()()
	vals := make([]string, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *StringSet) Add(val ...string) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *StringSet) Del(val ...string) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *StringSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *StringSet) Contains(val ...string) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *StringSet with the same elements
func (s *StringSet) Clone() *StringSet {
	defer s.readLock()()
	newSet := NewStringSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *StringSet with elements from both s and s2
func (s *StringSet) Union(s2 *StringSet) *StringSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *StringSet with elements that s and s2 have in common
func (s *StringSet) Intersection(s2 *StringSet) *StringSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *StringSet with the elements that exist in s but not s2
func (s *StringSet) Diff(s2 *StringSet) *StringSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// UintSet the set of Uints
type UintSet struct {
	mp map[uint]struct{}
	sync.RWMutex
}

// NewUintSet returns a new *UintSet with the initial size set to size
func NewUintSet(size int) *UintSet {
	return &UintSet{
		mp: make(map[uint]struct{}, size),
	}
}

func (s *UintSet) lock(others ...*UintSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *UintSet) readLock(others ...*UintSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *UintSet) Values() []uint {
	defer s.readLock()()
	vals := make([]uint, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *UintSet) Add(val ...uint) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *UintSet) Del(val ...uint) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *UintSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *UintSet) Contains(val ...uint) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *UintSet with the same elements
func (s *UintSet) Clone() *UintSet {
	defer s.readLock()()
	newSet := NewUintSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *UintSet with elements from both s and s2
func (s *UintSet) Union(s2 *UintSet) *UintSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *UintSet with elements that s and s2 have in common
func (s *UintSet) Intersection(s2 *UintSet) *UintSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *UintSet with the elements that exist in s but not s2
func (s *UintSet) Diff(s2 *UintSet) *UintSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Uint16Set the set of Uint16s
type Uint16Set struct {
	mp map[uint16]struct{}
	sync.RWMutex
}

// NewUint16Set returns a new *Uint16Set with the initial size set to size
func NewUint16Set(size int) *Uint16Set {
	return &Uint16Set{
		mp: make(map[uint16]struct{}, size),
	}
}

func (s *Uint16Set) lock(others ...*Uint16Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Uint16Set) readLock(others ...*Uint16Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Uint16Set) Values() []uint16 {
	defer s.readLock()()
	vals := make([]uint16, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Uint16Set) Add(val ...uint16) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Uint16Set) Del(val ...uint16) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Uint16Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Uint16Set) Contains(val ...uint16) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Uint16Set with the same elements
func (s *Uint16Set) Clone() *Uint16Set {
	defer s.readLock()()
	newSet := NewUint16Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Uint16Set with elements from both s and s2
func (s *Uint16Set) Union(s2 *Uint16Set) *Uint16Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Uint16Set with elements that s and s2 have in common
func (s *Uint16Set) Intersection(s2 *Uint16Set) *Uint16Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Uint16Set with the elements that exist in s but not s2
func (s *Uint16Set) Diff(s2 *Uint16Set) *Uint16Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Uint32Set the set of Uint32s
type Uint32Set struct {
	mp map[uint32]struct{}
	sync.RWMutex
}

// NewUint32Set returns a new *Uint32Set with the initial size set to size
func NewUint32Set(size int) *Uint32Set {
	return &Uint32Set{
		mp: make(map[uint32]struct{}, size),
	}
}

func (s *Uint32Set) lock(others ...*Uint32Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Uint32Set) readLock(others ...*Uint32Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Uint32Set) Values() []uint32 {
	defer s.readLock()()
	vals := make([]uint32, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Uint32Set) Add(val ...uint32) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Uint32Set) Del(val ...uint32) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Uint32Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Uint32Set) Contains(val ...uint32) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Uint32Set with the same elements
func (s *Uint32Set) Clone() *Uint32Set {
	defer s.readLock()()
	newSet := NewUint32Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Uint32Set with elements from both s and s2
func (s *Uint32Set) Union(s2 *Uint32Set) *Uint32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Uint32Set with elements that s and s2 have in common
func (s *Uint32Set) Intersection(s2 *Uint32Set) *Uint32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Uint32Set with the elements that exist in s but not s2
func (s *Uint32Set) Diff(s2 *Uint32Set) *Uint32Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Uint64Set the set of Uint64s
type Uint64Set struct {
	mp map[uint64]struct{}
	sync.RWMutex
}

// NewUint64Set returns a new *Uint64Set with the initial size set to size
func NewUint64Set(size int) *Uint64Set {
	return &Uint64Set{
		mp: make(map[uint64]struct{}, size),
	}
}

func (s *Uint64Set) lock(others ...*Uint64Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Uint64Set) readLock(others ...*Uint64Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Uint64Set) Values() []uint64 {
	defer s.readLock()()
	vals := make([]uint64, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Uint64Set) Add(val ...uint64) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Uint64Set) Del(val ...uint64) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Uint64Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Uint64Set) Contains(val ...uint64) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Uint64Set with the same elements
func (s *Uint64Set) Clone() *Uint64Set {
	defer s.readLock()()
	newSet := NewUint64Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Uint64Set with elements from both s and s2
func (s *Uint64Set) Union(s2 *Uint64Set) *Uint64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Uint64Set with elements that s and s2 have in common
func (s *Uint64Set) Intersection(s2 *Uint64Set) *Uint64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Uint64Set with the elements that exist in s but not s2
func (s *Uint64Set) Diff(s2 *Uint64Set) *Uint64Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// Uint8Set the set of Uint8s
type Uint8Set struct {
	mp map[uint8]struct{}
	sync.RWMutex
}

// NewUint8Set returns a new *Uint8Set with the initial size set to size
func NewUint8Set(size int) *Uint8Set {
	return &Uint8Set{
		mp: make(map[uint8]struct{}, size),
	}
}

func (s *Uint8Set) lock(others ...*Uint8Set) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *Uint8Set) readLock(others ...*Uint8Set) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *Uint8Set) Values() []uint8 {
	defer s.readLock()()
	vals := make([]uint8, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *Uint8Set) Add(val ...uint8) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *Uint8Set) Del(val ...uint8) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *Uint8Set) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *Uint8Set) Contains(val ...uint8) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *Uint8Set with the same elements
func (s *Uint8Set) Clone() *Uint8Set {
	defer s.readLock()()
	newSet := NewUint8Set(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *Uint8Set with elements from both s and s2
func (s *Uint8Set) Union(s2 *Uint8Set) *Uint8Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *Uint8Set with elements that s and s2 have in common
func (s *Uint8Set) Intersection(s2 *Uint8Set) *Uint8Set {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *Uint8Set with the elements that exist in s but not s2
func (s *Uint8Set) Diff(s2 *Uint8Set) *Uint8Set {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}

// UintptrSet the set of Uintptrs
type UintptrSet struct {
	mp map[uintptr]struct{}
	sync.RWMutex
}

// NewUintptrSet returns a new *UintptrSet with the initial size set to size
func NewUintptrSet(size int) *UintptrSet {
	return &UintptrSet{
		mp: make(map[uintptr]struct{}, size),
	}
}

func (s *UintptrSet) lock(others ...*UintptrSet) func() {
	s.Lock()
	for _, lck := range others {
		lck.Lock()
	}
	return func() {
		s.Unlock()
		for _, lck := range others {
			lck.Unlock()
		}
	}
}

func (s *UintptrSet) readLock(others ...*UintptrSet) func() {
	s.RLock()
	for _, lck := range others {
		lck.RLock()
	}
	return func() {
		s.RUnlock()
		for _, lck := range others {
			lck.RUnlock()
		}
	}
}

//Values returns all the values in the set in unspecified order
func (s *UintptrSet) Values() []uintptr {
	defer s.readLock()()
	vals := make([]uintptr, 0, len(s.mp))
	for k := range s.mp {
		vals = append(vals, k)
	}
	return vals
}

// Add adds new values to the set
func (s *UintptrSet) Add(val ...uintptr) {
	defer s.lock()()
	for _, v := range val {
		s.mp[v] = struct{}{}
	}
}

// Del deletes values from the set
func (s *UintptrSet) Del(val ...uintptr) {
	defer s.readLock()()
	for _, v := range val {
		delete(s.mp, v)
	}
}

//Len returns the number of items in the set
func (s *UintptrSet) Len() int {
	defer s.readLock()()
	return len(s.mp)
}

//Contains returns true if the set contains all given values
func (s *UintptrSet) Contains(val ...uintptr) bool {
	defer s.readLock()()
	for _, v := range val {
		_, ok := s.mp[v]
		if !ok {
			return false
		}
	}
	return true
}

//Clone returns a new *UintptrSet with the same elements
func (s *UintptrSet) Clone() *UintptrSet {
	defer s.readLock()()
	newSet := NewUintptrSet(s.Len())
	newSet.Add(s.Values()...)
	return newSet
}

//Union returns a new *UintptrSet with elements from both s and s2
func (s *UintptrSet) Union(s2 *UintptrSet) *UintptrSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Add(s2.Values()...)
	return n
}

//Intersection returns a new *UintptrSet with elements that s and s2 have in common
func (s *UintptrSet) Intersection(s2 *UintptrSet) *UintptrSet {
	defer s.readLock(s2)()
	n := s.Clone()
	for _, v := range n.Values() {
		if !s2.Contains(v) {
			n.Del(v)
		}
	}
	return n
}

//Diff returns a new *UintptrSet with the elements that exist in s but not s2
func (s *UintptrSet) Diff(s2 *UintptrSet) *UintptrSet {
	defer s.readLock(s2)()
	n := s.Clone()
	n.Del(s2.Values()...)
	return n
}
